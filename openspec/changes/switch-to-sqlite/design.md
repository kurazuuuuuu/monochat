# Design Document: SQLite移行

## Context
MonoChatは当初PostgreSQLを使用する設計でしたが、開発環境のセットアップを簡素化し、データベースサーバーの管理負担を軽減するため、SQLiteへの移行を行います。

### Background
- 開発時にPostgreSQLサーバーの起動・管理が必要
- 新規開発者のオンボーディングに障壁がある
- シンプルなアプリケーションであり、パフォーマンス要件は低い

### Stakeholders
- 開発者: 開発環境のセットアップが簡単になる
- エンドユーザー: 影響なし（デプロイ環境での実装に依存）

## Goals / Non-Goals

### Goals
- 開発環境のセットアップを簡素化
- データベースサーバーの起動・管理を不要に
- Rails標準の軽量データベースを使用
- 既存のデータモデル仕様を維持

### Non-Goals
- パフォーマンスの最適化
- 本番環境でのスケーラビリティ
- 複雑なデータベース機能（レプリケーション、シャーディングなど）
- 既存PostgreSQLデータの自動移行

## Decisions

### 1. データベース: SQLite
**決定**: PostgreSQLからSQLiteに変更

**理由**:
- Rails標準でサポートされており、追加設定が最小限
- ファイルベースのデータベースで、サーバー起動が不要
- 開発・テスト環境に最適
- シンプルなアプリケーションには十分な機能

**代替案**:
- PostgreSQL維持: サーバー管理の負担が継続
- MySQL: SQLiteと同様にサーバー管理が必要
- インメモリDB: データ永続化に課題

### 2. UUID管理: 文字列型
**決定**: PostgreSQL固有のUUID型から、文字列（VARCHAR）型でUUIDを管理

**理由**:
- SQLiteにネイティブなUUID型は存在しない
- 文字列型でUUIDを保存することで互換性を維持
- アプリケーション層でのUUID生成・検証は変更不要

**実装**:
- マイグレーションでUUID型を文字列型に変更
- インデックスは文字列型のまま維持
- バリデーションと一意性制約は継続

### 3. UUID拡張機能: 削除
**決定**: PostgreSQL固有の `uuid-ossp` または `pgcrypto` 拡張機能を削除

**理由**:
- SQLiteには該当する拡張機能が存在しない
- Ruby/RailsのSecureRandomでUUID生成可能
- データベース層でのUUID生成が不要

### 4. 接続プール設定: 簡素化
**決定**: SQLiteに適した接続プール設定を使用

**理由**:
- SQLiteはファイルベースで、PostgreSQLほど複雑な接続管理が不要
- デフォルト設定で十分なパフォーマンス

## Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                    Rails Backend                        │
│   ┌──────────────┐  ┌──────────────┐  ┌─────────────┐ │
│   │     User     │  │     Space    │  │   Message   │ │
│   │     Model    │  │     Model    │  │    Model    │ │
│   └──────────────┘  └──────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────────┘
                          │
                          ▼
┌─────────────────────────────────────────────────────────┐
│                  SQLite Database (File)                 │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐            │
│   │  users   │  │  spaces  │  │ messages │            │
│   │ (VARCHAR │  │ (VARCHAR │  │ (VARCHAR │            │
│   │  UUIDs)  │  │  UUIDs)  │  │  UUIDs)  │            │
│   └──────────┘  └──────────┘  └──────────┘            │
└─────────────────────────────────────────────────────────┘
```

## Data Flow

### UUID生成フロー（変更後）
1. アプリケーション層で `SecureRandom.uuid` を使用してUUID生成
2. 文字列型のカラムに保存
3. データベースレベルでの一意性制約で重複を防止

## Risks / Trade-offs

### Risk 1: 本番環境でのスケーラビリティ
- **リスク**: SQLiteは大規模なトラフィックや同時書き込みに弱い
- **緩和策**: 本番環境ではPostgreSQLなど他のデータベースを使用する選択肢を残す

### Risk 2: SQLite特有の制限
- **リスク**: ALTER TABLE の一部機能に制限がある
- **緩和策**: マイグレーション設計時に制限を考慮

### Trade-off: シンプルさ vs パフォーマンス
- **選択**: パフォーマンスよりシンプルさを優先
- **理由**: MVP段階であり、開発体験の向上が最重要

### Trade-off: PostgreSQL固有機能の放棄
- **選択**: PostgreSQL固有のUUID型、拡張機能を放棄
- **理由**: MonoChatで使用する機能は全てSQLiteで実現可能

## Migration Plan

### 移行手順
1. **Gemfile更新**
   - `pg` gemを削除
   - `sqlite3` gemを追加（既にRails標準で含まれている可能性）
   
2. **database.yml更新**
   - PostgreSQL設定を削除
   - SQLite設定を追加
   
3. **マイグレーション修正**
   - UUID拡張機能マイグレーションを削除
   - UUID型カラムを文字列型に変更
   
4. **データベース再構築**
   - `rails db:drop db:create db:migrate`
   
5. **動作確認**
   - テストスイートの実行
   - 開発サーバーでの動作確認

### ロールバック
PostgreSQLに戻す場合:
1. Gemfileを元に戻す
2. database.ymlを元に戻す
3. マイグレーションを復元
4. データベース再構築

## Open Questions
- 本番環境でもSQLiteを使用するか、それとも別のデータベースを使用するか？
  - **暫定回答**: 開発環境はSQLite、本番環境は要件に応じて決定（初期段階ではスコープ外）
